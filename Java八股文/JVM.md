# JVM

## Java内存区域分配 / 运行时的数据区 / JVM虚拟机内存模型

线程共享的区域：

- 方法区：存储类信息、常量、静态变量等信息，还包含了运行时的常量池，后者存储了编译器生成的各种字面量和符号引用；
- 堆：大部分对象实例和数组都是在堆完成内存分配的，垃圾回收的主要区域，如果堆中没有内存可以完成实例分配，并且堆也无法扩展时，将抛出OutOfMemoryError；

线程私有的区分：

- 程序计数器：当前线程所执行的字节码的行号指示器
- 虚拟机栈：是Java方法执行时的线程内存模型，每个方法被调用时都会同步创建一个栈帧，用于存储局部变量表、操作数栈、动态连接、方法出口等信息；
- 本地方法栈：作用与虚拟机栈相同，但是服务于本地方法（native method）；

### 与规范中的区别

- 直接内存：Java NIO中，为了防止Java堆和Native堆之间往复的数据复制带来的性能损耗，NIO可以使用native的方式直接在Native堆分配内存，这块区域也可能导致OutOfMemoryError；
- 元数据区（方法区的实现）：Java8中使用元数据区替代了永久区来实现方法区，元数据区不在虚拟机，而是使用本地内存；

### 逃逸分析

- 逃逸是指在某个方法内创建的对象在方法体之外被其他变量引用了，其带来的后果的是在方法执行完毕之后，该对象无法被GC回收；
- 逃逸分析技术是编译器的优化技术之一，可以分析出某个对象是否永远只在某个方法、线程的范围内，其结果是对未逃逸的对象可以直接在栈上分配内存（Java对象不都是在堆上分配内存的），从而这部分空间可以随着出栈而销毁；

## 垃圾收集

### 哪些对象被回收

#### 判断对象已死的算法

- 引用计数器算法：一个对象每当有一个地方引用它时，计数就加一，引用失效时计数减一，任何时刻计数器为0的对象会被认为不可用；
- 可达性分析算法：从GC Root作为起始点向下搜索，一个对象和GC Root之间没有任何引用链，则证明对象不可用；

#### 引用

从强到弱：强引用、软引用、弱引用、虚引用

### 垃圾收集算法

- 标记清除算法；
- 标记复制算法；
- 标记整理算法；
- 分代收集算法：把内存区域分为新生代和老年代，按照不同算法进行收集；

### 内存分配策略

- 优先在Eden区分配；
- 大对象直接进入老年代；
- Eden区中经历过一次Minor GC的对象进入Survivor区；
- Survivor中对象年龄（经历Minor GC的次数）达成一定程度时进入老年区；

### Minor GC与Full GC

- 当Eden区空间不足以继续分配对象时，发起Minor GC；
- 老年代空间不足或方法区空间不足时，发起Minor GC；

### 垃圾收集器

Serial收集器：单线程回收；

Parallel收集器：可控的吞吐量，精准控制吞吐量和最大停顿时间；

CMS收集器：以最短停顿时间为目标的收集器；

G1收集器：面向服务端应用的垃圾收集器，全功能收集器，在延迟可控的情况下获得尽可能高的吞吐量；

### Stop the world

- 在执行垃圾收集器算法时，应用程序中的其他所有线程都被挂起；
- 所有的垃圾收集器都会STW，只能尽量减少STW的时间；
- 因为在定位堆的对象是时JVM会记录下所有对象的引用，如果在定位对象过程中，有新的对象被分配或刚记录下的对象突然变得无法访问，则会导致一些问题，所以一定要STW；

## 类加载机制

### 加载过程

- 加载：获取来自任意来源的字节流并转换成运行时数据结构，生成Class对象；
- 验证：验证字节流信息是否符合当前虚拟机的要求，防止被篡改过的字节码危害虚拟机安全；
- 准备：为类变量分配内存并设置初始值；
- 解析：将常量池中的符号引用替换为直接引用，符号引用是一组符号来描述所引用的目标，直接引用是指向目标的指针；
- 初始化：执行类构造器、类变量赋值、静态语句块等；

### 类加载器

- 启动类加载器（Bootstrap ClassLoader）：C++实现，虚拟机的一部分，无法被Java程序直接引用，加载/lib下的核心类库；
- 扩展类加载器（Extension ClassLoader）：Java实现，加载/lib/ext或-Djava.ext.dir系统变量指定路径下的类库
- 应用类加载器（Application ClassLoader）：Java实现，加载ClassPath指定路径下的类库；

### 双亲委派

- 当一个类加载器收到类加载的请求，会首先将请求委托给父加载器完成，并且依次向上传递，倘若父加载器无法完成此加载任务，子加载器才会尝试自己去加载；
- 其优点是Java类随着它的类加载器而具备了一种带有优先级的层次关系，通过这种层次关系可以避免类的重复加载，以及防止恶意覆盖Java核心API；

**破坏双亲委派模型的事件**

- 在双亲委派模型出来之前，用户继承ClassLoader就是为了重写loadClass方法，自1.2之后添加了findClass供以后的用户重写；
- 如果基础类要调用用户的代码，比如JNDI服务由启动类加载器完成加载，它需要调用下层的ClassPath下的代码，而启动类加载器是无法加载的。为解决此问题，Java团队增加了一个线程上下文加载器，如果加载器没有被设置过，则默认使用应用类加载器；
- 为了实现代码热替换，比如OSGi；

## Java内存模型

- Java内存模型是一种规范，定义了程序中各种变量的访问规则，用于解决多线程中通过共享内存进行通信时，存在的本地内存数据不一致、编译器对代码指令重排序、处理器会对代码乱序执行等带来的问题，从而保证了并发场景中的可见性、原子性和有序性；
- Java提供了volatile、synchronized、final等关键字；

### 主内存与工作内存

JMM规定了所有变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，不同线程无法直接访问对象工作线程内存中的变量，线程间的变量的传递均需要通过主内存完成；

### 原子性、可见性和有序性

- 原子性：操作不可分割；
- 可见性：当一个线程修改了共享变量的值时，其他线程可以立刻得知这个修改；
- 有序性：在一个线程内的所有操作都是有序的；

### 先行发生原则（happens-before）

定义Java内存模型中两项操作之间的顺序关系，发生在之后的操作收到之前发生的操作的影响（能观察到之后的操作所做的修改）。具体有以下规则：

- 程序次序规则：一个线程内，书写在前操作先于书写在后面的操作；
- 锁定管理规则：一个unlock操作先于发生于后面的对同一个锁的lock操作；
- volatile规则：对一个volatile变量的写操作先于发生于后面的对这个变量的读操作；
- 线程启动规则：Thread对象的start()方法先于对此线程的每一个动作；
- 线程终止规则：线程中的所有操作先于对线程的终止检测；
- 线程中断规则：对线程的interrupt()方法的调用先行于被中断线程代码检测到中断时间的发生；
- 对象终结规则：一个对象的初始化先于它的finalize()方法的开始；
- 传递性：if A > B, B > C, then A > C；

### 线程安全实现

#### Volatile的实现

volatile保证了变量的有序性和可见性：

- 当一个线程修改了这个变量的值，volatile保证了新值可以立即被同步到主内存，以及每次使用前从主内存刷新；
- 有序性：volatile修饰的变量，禁止之后发生的指令被CPU重排序到volatile赋值指令之前；

#### synchronized的实现

- 使用互斥同步的方式实现，synchronized关键字经编译后会在同步块前后分别添加monitorenter和monitorexit两条字节码指令；
- 在执行monitorenter执行时，线程会尝试去获取对象的锁，如果其没被锁定，或当前线程已经持有了那个锁（所以synchronized是可重入的），则把锁的计数器值加1，在执行monitorexit时会把计数器的值减1，一旦计数器的值为0，则释放锁；
- synchronized是重量级锁，但是虚拟机本身会对其进行一些优化；

#### Lock

- 用户能够以非块结构使用；
- ReentrantLock，相比synchronized增加了等待可中断（tryLock指定超时时间）、公平锁的实现（使用公平锁会导致ReentrantLock性能急剧下降）、以及Condition；
- 自JDK6起对synchronized优化之后，其性能和ReentrantLock基本持平；

### 锁优化

- 自旋锁：在获取不到锁时需要阻塞该线程前，先让其循环等待，节省挂起线程和恢复线程的消耗，适用于线程持有锁时间很短的场景）；
- 锁消除：基于逃逸分析，如果判断一段代码中在堆上的数据都会逃逸，则将它们当做是栈上数据，无需加锁；
- 锁粗化：反复对同一个锁加锁和解锁时，把加锁和解锁放在整个操作外部；
- 轻量级锁和偏向锁；

## JVM调优

没调过

