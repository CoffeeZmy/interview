# 面试题——数据库

[TOC]



## 1.MySQL索引

https://www.kancloud.cn/kancloud/theory-of-mysql-index/41855

索引是帮助MySQL高效获取数据的数据结构，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引；

### B-Tree

参考：https://www.cnblogs.com/qixinbo/p/11048269.html

#### B-Tree

- B-Tree是一种多路搜索树，非二叉树；
- 其根节点的儿子数为[2,M]，根节点以外的叶子节点的儿子数为[M/2,M]；
- 非叶子节点的关键字K[i] < K[i+1]，所有的值都是按顺序存储的；
- 其非叶子节点的关键字个数等于指向儿子的指针个数-1，指针P[i]指向关键字属于(K[i-1], K[i])的子树；
- 所有叶子节点位于同一层；

##### B-Tree的搜索

- B-Tree的搜索，从根节点开始，对节点内的关键字进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子节点，重复搜索直到所对应的儿子指针为空或已经是叶子节点；
- 其搜索性能等价于在关键字全集内做一次二分查找，O(logN)的时间复杂度；

##### 自动层次控制

- 由于限制了根节点以外的非叶子节点，至少含有M/2个儿子，确保了节点的至少利用率；
- 由于M/2的限制，在插入节点时，如果节点已满，需要将节点分裂为两个各占M/2的节点，删除节点时需将两个不足M/2的兄弟节点合并；

##### B-Tree相对于二叉搜索树

B-Tree降低了树的高度，从而减少了I/O的次数

##### 应用

B树主要应用于文件系统以及部分数据库索引，如MongoDB

#### B+树

参考：https://www.cnblogs.com/nanlinghan/p/10315653.html#top

- 其非叶子节点的元素个数等于指向儿子的指针树（注意B-Tree是比指针数少1）；
- 每个元素不保存数据，只用来索引，所有的数据都保存在叶子节点，所有叶子节点包含了全部元素的信息，及指向含这些元素记录的指针；
- 叶子节点本身按关键字大小自小而大顺序链接，关键字小的叶子节点指向关键字大的叶子节点；
- 所有中间节点元素都同时存在于子节点，在子节点元素中是最大或最小元素；

##### 卫星数据

- 索引元素所指向的数据记录，比如数据库的某一行，在B-Tree中，无论是中间节点还是叶子节点都带有卫星数据，而在B+Tree中，只有叶子节点带有卫星数据，其余中间节点只是索引，没有任何数据关联；
- 在聚簇索引中， 叶子节点之间包含卫星数据，在非聚簇索引中，叶子节点带有指向卫星数据的指针；

##### B+树的搜索

B+树自顶向下根据逐层查找节点，最终找到匹配的叶子节点；

##### B+树的优点

- B+树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的节点元素，这就意味着在数据量相同时，B+树更加矮胖，从而减少IO次数；
- 所有的查询都要查找到叶子节点，查询性能稳定；
- 所有的叶子节点形成有序联表，便于范围查询；

### 为什么使用B-Tree/B+Tree来实现索引

- **磁盘I/O消耗大**：索引往往以文件的形式存储在磁盘上，索引查找过程中会产生磁盘I/O消耗；
- **磁盘预读**：磁盘往往不是严格按需读取，而是每次都会从需要的位置顺序向后也读取一定长度的数据放入内存中，每次读取的长度为页的整数倍。数据库设计者把节点大小设置为页的大小，这样只需要一次磁盘I/O就能把整个节点载入到内存中，从而减少了I/O次数；
- **数据结构优势**：相比链表，查询更快。相比数组，插入、修改、删除性能好。相比其他树，B-Tree/B+Tree深度小，从减少了查询过程中磁盘I/O的次数；

### MySQL索引的实现

#### MyISAM索引实现

- MyISAM使用B+Tree作为索引结构；
- MyISAM的索引文件仅仅保存数据记录的地址；

#### InnoDB索引实现

- InnoDB使用B+Tree作为索引结构；
- InnoDB使用了聚簇索引（按主键聚集数据）的存储方式，索引文件会保存数据行本身；
- InnoDB的辅助索引都引用主键作为data域（而不是地址），在通过辅助索引检索数据时，先通过辅助索引获得主键值，再通过主索引（聚簇索引）获得记录；

**聚簇索引**

- 一种数据存储的方式，即在同一个结构中保存B+Tree索引和数据行，使用主键来聚集数据，数据行存储在索引的叶子节点；
- 当插入新行或主键被更新导致需要移动行的时候，可能面临页分裂的问题，比如当前行的主键值被要求插入到某个已满的页，存储引擎会将该页分裂为两个页；
- 使用聚簇索引（即对于InnoDB引擎），主键在非特殊情况下必须使用自增主键，因为插入新行时只用在当前索引节点的下一个位置插入，而不用移动之前的节点；

### B-Tree和B+Tree的区别

- B-Tree的每个节点都保存数据，单词搜索的时间复杂度在O(1)和O(logN)之间，B+Tree只在叶子节点保存数据，搜索的时间复杂度稳定为O(logN)。且由于B+Tree的非叶子节点不保存数据，所以其非叶子节点占用磁盘空间更小，相对于B-Tree降低了树的高度；
- B+Tree的叶子节点依次连接，所以更有利于遍历和范围查询；

### 为什么MySQL要用B+树，MongoDB要用B树

因为B-Tree每个节点都保存数据，单次查询时间复杂度在O(1)和O(logN)之间，B+Tree只在叶子节点保存数据，查询的时间复杂度稳定在O(logN)，所以B-Tree单次查询的性能更好，更适合MongoDB这种NoSQL（单次查询即可查询出关联的Json数据）。且B+Tree叶子节点之间互相连接，所以更适合范围查询和数据遍历，所以更适合MySQL这种关系型数据库；

## 2.大库DDL怎么做比较好

可以创建新表，导入旧表的数据，然后通过改名交换两张表；

## 3.事务、锁、MySQL事务

### 脏读、不可重读读、幻读

- 脏读：读到了别的事务未提交的修改；
- 不可重复读：事务A读取了数据，在执行逻辑的过程中数据被其他事务修改了；
- 幻读：事务A根据查询条件查询到了M条数据，然后事务B新增或修改了N条数据，使这N条数据也符合了A的查询条件；

### 隔离级别

- Serializable（串行化）：事务串行执行，资源消耗最大；
- Repeatable Read（可重复读）：保证了一个事务不会修改已经由另一个事务读取但是未提交的数据，避免了脏读和不可重复读，不可避免幻读；
- Read Committed（读已提交）：保证了一个事务不会读到另一个事务已修改但是未提交的数据，避免了脏读；
- Read Uncommitted：事务中的修改，即使没有提交，其他事务也可以看到；

### 事务ACID

- 原子性（Atomicity）：事务不可分割，事务中的所有操作要么都成功，要么都失败；
- 一致性（Consistency）：事务前后数据的完整性必须保持一致（如银行取钱）；
- 隔离性（Isolation）：不同事务相互隔离；
- 持久性（Durability）：事务一旦被提交，它对数据的改变就是永久性的；

### 锁

#### 读写锁

读锁又被称为共享锁，写锁又被称为排他锁；

#### 锁粒度

- 表锁：粒度为整张表，一个事务获取某张表的表锁后，会阻塞其他事务对该表的所有读写操作；
- 行锁：粒度为单行或多行，阻塞其他事务对被锁的这些行的读写操作。InnoDB实现了行锁；

#### InnoDB行锁

https://zhuanlan.zhihu.com/p/48269420

InnoDB行锁的策略有Record Lock、Gap Lock（间隙锁）和Next-Key Lock（临键锁）等，后两者是为了解决幻读问题；

#### MySQL触发锁的时机

https://www.cnblogs.com/Marydon20170307/p/14105005.html

### MySQL MVCC（多版本并发控制）

#### MySQL InnoDB引擎如何实现MVCC

- InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的，一个保存行的创建时的版本号，一个保存行的被删除时的版本号，每开始一个新的事务，系统的版本号就会加1；
- insert和delete时分别把当前系统版本号作为创建版本号和删除版本号；
- select只查找版本早于当前事务版本的数据行并且删除版本未定义或删除版本大于当前事务版本的数据行；
- update则是插入新记录，并删除旧记录（通过设置删除版本号）

MVCC只在可重复读和读已提交的隔离级别下工作，而Serializable则会对所有读取的行都加锁；

#### MySQL（InnoDB）如何解决幻读

https://zhuanlan.zhihu.com/p/145822414

通过MVCC和行锁解决，在隔离级别为Repeatable Read时（即默认情况），在一次事务中多个select查询到的数据都是事务开始时那个状态的数据。如果使用了select for update并且是范围查询，则执行时会申请行锁中的Gap Lock和Next-Key Lock，其他事务无法向被锁住的区间插入数据，从而解决幻读；

## 4.MySQL日志

https://zhuanlan.zhihu.com/p/58011817

### MySQL有哪些日志

- 错误日志：记录服务器发生的错误的信息；
- 查询日志：记录数据库中执行的所有sql命令；
- 慢查询日志：记录查询超过指定时间的语句；
- 事务日志（redo log和undo log）：InnoDB的事务，用于保证事务的ACID；
- 二进制日志（Binary log）：是一个二进制文件，记录所有数据库表结构变更及数据修改，不记录select、show等不修改数据的sql；
- 中继日志（Relay log）：复制过程中产生的日志，从库服务器I/O线程将主库服务器的二进制日志读取过来到从库服务器本地文件，然后从库的SQL线程会读取relay-log的内容并应用到从库服务器；

### 事务日志redo log与undo log

- 事务日志包括两部分：一是内存中的日志缓冲（log buffer），二是磁盘上的日志文件log file，后者是持久性的；
- InnoDB在事务提交的时候，必须先将事务的所有日志写入磁盘上的redo log和undo log中进行持久化。如果在事务未刷新到磁盘时数据库断电了，即可以通过redo log来重刷这些记录。Undo log就是在数据修改时，InnoDB除了记录了redo log，还记录了对应的相反操作的undo log，在执行回滚时，就可以从undo log中的逻辑记录读取到相应的内容并回滚；
- InnoDB使用日志来减少提交事务时的开销，因为日志中已经记录了事务，就无须在每个事务提交时把缓冲池的脏块刷新到磁盘中，并且通过顺序写日志，把持久化事务的过程由随机I/O变为了顺序I/O；
- 在每次将log buffer中的日志写入到日志文件的过程中都会调用一次操作系统的fsync，强制将OS buffer中的日志刷到磁盘上的log file中；
- MySQL支持用户自定义在提交事务时如何将log buffer中的日志刷到log file中，即设置innodb_flush_log_at_trx_commit的值，其默认值为1，表示每次提交事务时都会将log buffer持久化到log file中，这也是最安全的设置，可以保证不会丢失任何已提交的事务；

### Binary log与Relay log

#### Binary log

**定义**：是一个二进制文件，记录所有数据库表结构变更及数据修改，并且记录了语句发生时间、执行时长、操作数据等其它额外信息，不记录select、show等不修改数据的sql；

**作用**：

- 恢复：数据的恢复需要二进制日志；
- 复制：通过复制实现主库与同库实时同步；
- 审计：可通过二进制日志中的信息进行审计，判断是否对数据库进行注入攻击；
- binlog对于事务存储引擎的崩溃恢复也有非常重要的作用。在开启binlog的情况下，为了保证binlog与redo的一致性，MySQL将采用事务的两阶段提交协议，当MySQL崩溃时，事务在存储引擎内部的状态可能为prepared和commit两种，对于prepared状态的事务，如果事务在binlog中存在，则将其提交，如果不在binlog存在，则将其回滚，这样就保证了数据在主库和从库之间的一致性；

#### Relay log

relay log是复制过程中产生的日志，和binary log差不多，区别是relay log是从库服务器I/O线程将主库服务器的二进制日志读取过来记录到从库服务器本地文件的，然后从库的SQL线程会读取relay-log日志的内容并应用到从库服务器上；

## 5.InnodDB的事务是如何实现的

- InnoDB通过Redo log和Undo log实现事务的原子性、一致性和持久性，通过锁和MVCC实现隔离性；
- InnoDB在提交事务之前，会先把事务写入到Redo log中进行持久化，实现了事务的原子性和持久性，并且在写入Redo log时也会将相反的操作记录到Undo log中，可通过Undo log对事务进行回滚，保证了事务的一致性；
- InnoDB对每一行数据都会记录数据插入时和被删除时的系统的版本号（即MVCC），在可重复读的隔离级别下，在一个事务中的所有select操作读取到的数据都是事务开启时的版本的数据，另外还通过间隙锁、next-key lock解决幻读的问题，从而实现了事务的隔离性；

## 6.MySQL集群如何保证数据的一致性

可通过MySQL的复制实现集群中各个节点数据的一致性，具体来说是通过binlog。首先主库把数据更改记录到binlog中，然后备库启动一个工作线程与主库建立连接，从主库上把binlog复制到自己的relay log，最后备库通过SQL线程读取relay log中的事件，将其重放到备库中；

## 7.MySQL集群如何保证高并发

- 读写分写：把读请求分发到多个只读从库，减小主库的压力；
- 缓存：在应用层和数据库之间增加缓存层，通常可以使用Redis和Memcached；
- 分库分表：通过分库，把写请求分发到多个库，通过分表，减小单表数据量带来的性能瓶颈；

## 8.MySQL集群如何保证高可用

- 避免单点故障：可通过同步复制保证至少有一台备库具有实时的数据副本；
- 故障转移：主备切换；



